<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!--
      Journal extension for Owlbear Rodeo

      This extension is a lightweight reâ€‘implementation of the DummySheet
      extension that stores a simple sheet for each player.  It has been
      modified so that the game master (GM) can edit any player's sheet,
      while regular players can see every sheet but may only edit their own.
      A rich text notes field has been added with basic formatting
      controls and the area is taller to accommodate longer notes.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Journal</title>
    <link rel="icon" type="image/svg+xml" href="/icon.svg" />
    <style>
      :root {
        --accent: #e6c927;
        --primary: #333;
        --secondary: #fafafa;
      }
      body {
        margin: 0;
        font-family: sans-serif;
        background: var(--secondary);
        color: var(--primary);
      }
      /* Tabs along the top for switching between players */
      #tabs {
        display: flex;
        flex-wrap: wrap;
        list-style: none;
        margin: 0;
        padding: 0;
        background: rgba(0, 0, 0, 0.1);
      }
      #tabs li {
        margin: 0;
        padding: 0;
      }
      #tabs button {
        border: none;
        margin: 0;
        padding: 0.5rem 1rem;
        background: transparent;
        cursor: pointer;
        color: rgba(0, 0, 0, 0.6);
        transition: background 0.15s ease, color 0.15s ease;
      }
      #tabs button.active {
        background: #fff;
        color: var(--accent);
        font-weight: bold;
      }
      #tabs button:hover {
        background: rgba(0, 0, 0, 0.05);
        color: rgba(0, 0, 0, 0.8);
      }
      /* Main sheet container */
      #sheet {
        padding: 1rem;
      }
      h2 {
        margin-top: 0;
        margin-bottom: 0.5rem;
        color: var(--accent);
      }
      /* Section styling */
      .section {
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: #fff;
        margin-bottom: 0.75rem;
        padding: 0.5rem;
        position: relative;
      }
      .section-title {
        font-weight: bold;
        margin: 0 0 0.5rem 0;
      }
      .section-remove {
        position: absolute;
        top: 0.25rem;
        right: 0.25rem;
        border: none;
        background: transparent;
        color: #c00;
        cursor: pointer;
        font-size: 1.2rem;
      }
      /* Stats rows */
      .stat-row {
        display: flex;
        margin-bottom: 0.25rem;
      }
      .stat-name,
      .stat-value {
        flex: 1;
        border: 1px solid rgba(0, 0, 0, 0.15);
        padding: 0.25rem;
        background: #f9f9f9;
        min-height: 1.5rem;
      }
      .stat-remove {
        border: none;
        background: transparent;
        color: #c00;
        cursor: pointer;
        font-size: 1rem;
        margin-left: 0.25rem;
      }
      /* Buttons */
      .add-btn {
        display: inline-block;
        margin-top: 0.25rem;
        padding: 0.25rem 0.5rem;
        border: 1px solid var(--accent);
        background: var(--accent);
        color: #fff;
        cursor: pointer;
        font-size: 0.875rem;
        border-radius: 0.15rem;
      }
      .add-btn:hover {
        opacity: 0.85;
      }
      /* Notes */
      .notes-container {
        margin-top: 1rem;
      }
      .toolbar {
        display: flex;
        gap: 0.25rem;
        flex-wrap: wrap;
        margin-bottom: 0.25rem;
      }
      .toolbar button,
      .toolbar input[type="color"] {
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: #fff;
        padding: 0.25rem;
        cursor: pointer;
      }
      .notes-editor {
        border: 1px solid rgba(0, 0, 0, 0.2);
        background: #fff;
        min-height: 8rem;
        padding: 0.5rem;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <ul id="tabs"></ul>
    <div id="sheet"></div>
    <script type="module">
      /*
        Journal extension script

        This script uses the Owlbear Rodeo SDK loaded via jsDelivr.  It
        maintains a simple character sheet for each player in the room.  The
        sheet contains a name, a notes section and a list of sections each
        containing a list of stats.  Data is stored in player metadata under
        the key "journal" so that it persists across sessions.  All players
        can view one another's sheets.  The GM can edit any sheet while
        regular players may only edit their own.  When the GM edits another
        player's sheet the update is sent via the broadcast API so that
        the remote player can update their metadata accordingly.  Remote
        players listen on the same broadcast channel and update their own
        metadata when they receive an update.
      */
      import OBR from "https://cdn.jsdelivr.net/npm/@owlbear-rodeo/sdk";

      // State variables
      let currentPlayerId = "";
      let isGM = false;
      let viewingPlayerId = "";
      // Map of playerId -> player object
      const players = new Map();
      // Map of playerId -> sheet object
      const sheets = {};

      // DOM references
      const tabsEl = document.getElementById("tabs");
      const sheetEl = document.getElementById("sheet");

      // Generate a default sheet for a new player
      function defaultSheet(player) {
        return {
          id: player.id,
          name: `${player.name}'s Journal`,
          notes: "",
          sections: [],
        };
      }

      // Render the player tabs
      function renderTabs() {
        tabsEl.innerHTML = "";
        players.forEach((player, id) => {
          const li = document.createElement("li");
          const btn = document.createElement("button");
          btn.textContent = player.name;
          if (id === viewingPlayerId) btn.classList.add("active");
          btn.addEventListener("click", () => {
            viewingPlayerId = id;
            renderTabs();
            renderSheet();
          });
          li.appendChild(btn);
          tabsEl.appendChild(li);
        });
      }

      // Save the current sheet back to metadata or broadcast to remote
      function saveSheet() {
        const sheet = sheets[viewingPlayerId];
        if (!sheet) return;
        if (viewingPlayerId === currentPlayerId) {
          // Save to our own metadata
          OBR.player.setMetadata({ journal: sheet });
        } else if (isGM) {
          // Broadcast to remote player so they can save their metadata
          OBR.broadcast.sendMessage("com.journal.update", {
            playerId: viewingPlayerId,
            sheet,
          });
        }
      }

      // Create a notes toolbar with formatting controls
      function createToolbar(editor) {
        const toolbar = document.createElement("div");
        toolbar.className = "toolbar";
        const buttons = [
          { cmd: "bold", label: "B" },
          { cmd: "italic", label: "I" },
          { cmd: "underline", label: "U" },
        ];
        buttons.forEach(({ cmd, label }) => {
          const btn = document.createElement("button");
          btn.textContent = label;
          btn.addEventListener("click", () => {
            document.execCommand(cmd);
            // update notes field after formatting
            const sheet = sheets[viewingPlayerId];
            sheet.notes = editor.innerHTML;
            saveSheet();
          });
          toolbar.appendChild(btn);
        });
        // Foreground color picker
        const fore = document.createElement("input");
        fore.type = "color";
        fore.addEventListener("input", (ev) => {
          document.execCommand("foreColor", false, ev.target.value);
          const sheet = sheets[viewingPlayerId];
          sheet.notes = editor.innerHTML;
          saveSheet();
        });
        toolbar.appendChild(fore);
        // Background highlight color picker
        const back = document.createElement("input");
        back.type = "color";
        back.addEventListener("input", (ev) => {
          // hiliteColor sets the background of the selected text
          document.execCommand("hiliteColor", false, ev.target.value);
          const sheet = sheets[viewingPlayerId];
          sheet.notes = editor.innerHTML;
          saveSheet();
        });
        toolbar.appendChild(back);
        return toolbar;
      }

      // Render the sheet UI
      function renderSheet() {
        const sheet = sheets[viewingPlayerId];
        if (!sheet) {
          sheetEl.innerHTML = "<p>No sheet found.</p>";
          return;
        }
        sheetEl.innerHTML = "";
        // Editable check
        const editable = isGM || viewingPlayerId === currentPlayerId;
        // Name/title
        const title = document.createElement("h2");
        title.textContent = sheet.name;
        if (editable) {
          title.contentEditable = "true";
          title.addEventListener("input", () => {
            sheet.name = title.textContent || "";
            saveSheet();
          });
        }
        sheetEl.appendChild(title);

        // Sections container
        sheet.sections.forEach((section) => {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "section";
          // Section title
          const sectTitle = document.createElement("div");
          sectTitle.className = "section-title";
          sectTitle.textContent = section.name;
          if (editable) {
            sectTitle.contentEditable = "true";
            sectTitle.addEventListener("input", () => {
              section.name = sectTitle.textContent || "";
              saveSheet();
            });
          }
          sectionDiv.appendChild(sectTitle);
          // Remove section button
          if (editable) {
            const rmSect = document.createElement("button");
            rmSect.className = "section-remove";
            rmSect.textContent = "Ã—";
            rmSect.addEventListener("click", () => {
              const idx = sheet.sections.findIndex((s) => s.id === section.id);
              if (idx !== -1) {
                sheet.sections.splice(idx, 1);
                renderSheet();
                saveSheet();
              }
            });
            sectionDiv.appendChild(rmSect);
          }
          // Stats list
          section.stats.forEach((stat) => {
            const row = document.createElement("div");
            row.className = "stat-row";
            const nameEl = document.createElement("div");
            nameEl.className = "stat-name";
            nameEl.textContent = stat.name;
            if (editable) {
              nameEl.contentEditable = "true";
              nameEl.addEventListener("input", () => {
                stat.name = nameEl.textContent || "";
                saveSheet();
              });
            }
            row.appendChild(nameEl);
            const valueEl = document.createElement("div");
            valueEl.className = "stat-value";
            valueEl.textContent = stat.value;
            if (editable) {
              valueEl.contentEditable = "true";
              valueEl.addEventListener("input", () => {
                stat.value = valueEl.textContent || "";
                saveSheet();
              });
            }
            row.appendChild(valueEl);
            if (editable) {
              const rm = document.createElement("button");
              rm.className = "stat-remove";
              rm.textContent = "Ã—";
              rm.addEventListener("click", () => {
                const i = section.stats.findIndex((s) => s.id === stat.id);
                if (i !== -1) {
                  section.stats.splice(i, 1);
                  renderSheet();
                  saveSheet();
                }
              });
              row.appendChild(rm);
            }
            sectionDiv.appendChild(row);
          });
          // Add stat button
          if (editable) {
            const addStat = document.createElement("button");
            addStat.className = "add-btn";
            addStat.textContent = "Add Stat";
            addStat.addEventListener("click", () => {
              const newId = section.stats.length > 0
                ? Math.max(...section.stats.map((s) => s.id)) + 1
                : 1;
              section.stats.push({ id: newId, name: "New Field", value: "-" });
              renderSheet();
              saveSheet();
            });
            sectionDiv.appendChild(addStat);
          }
          sheetEl.appendChild(sectionDiv);
        });
        // Add section button
        if (editable) {
          const addSection = document.createElement("button");
          addSection.className = "add-btn";
          addSection.textContent = "Add Section";
          addSection.addEventListener("click", () => {
            const newId = sheet.sections.length > 0
              ? Math.max(...sheet.sections.map((s) => s.id)) + 1
              : 1;
            sheet.sections.push({
              id: newId,
              name: "New Section",
              stats: [ { id: 1, name: "New Field", value: "-" } ],
            });
            renderSheet();
            saveSheet();
          });
          sheetEl.appendChild(addSection);
        }
        // Notes
        const notesContainer = document.createElement("div");
        notesContainer.className = "notes-container";
        const notesHeader = document.createElement("h3");
        notesHeader.textContent = "Notes";
        notesHeader.style.color = getComputedStyle(document.documentElement).getPropertyValue("--accent");
        notesContainer.appendChild(notesHeader);
        const editor = document.createElement("div");
        editor.className = "notes-editor";
        editor.innerHTML = sheet.notes;
        if (editable) {
          const toolbar = createToolbar(editor);
          notesContainer.appendChild(toolbar);
          editor.contentEditable = "true";
          editor.addEventListener("input", () => {
            sheet.notes = editor.innerHTML;
            saveSheet();
          });
        }
        notesContainer.appendChild(editor);
        sheetEl.appendChild(notesContainer);
      }

      // Initialize the extension when ready
      OBR.onReady(async () => {
        const party = await OBR.party.getPlayers();
        currentPlayerId = await OBR.player.getId();
        viewingPlayerId = currentPlayerId;
        isGM = (await OBR.player.getRole()) === "GM";
        // Populate initial players and sheets
        party.forEach((p) => {
          players.set(p.id, p);
          const sheet = p.metadata.journal || p.metadata.dummysheet;
          sheets[p.id] = sheet ? JSON.parse(JSON.stringify(sheet)) : defaultSheet(p);
        });
        // Render initial UI
        renderTabs();
        renderSheet();
        // Update when party changes (players join/leave or metadata updates)
        OBR.party.onChange((newParty) => {
          players.clear();
          newParty.forEach((p) => {
            players.set(p.id, p);
            const sheet = p.metadata.journal || p.metadata.dummysheet;
            sheets[p.id] = sheet ? JSON.parse(JSON.stringify(sheet)) : defaultSheet(p);
          });
          // If the current viewing player no longer exists, default to current player
          if (!players.has(viewingPlayerId)) {
            viewingPlayerId = currentPlayerId;
          }
          renderTabs();
          renderSheet();
        });
        // Listen for broadcast messages about sheet updates
        OBR.broadcast.onMessage("com.journal.update", (event) => {
          const { playerId, sheet } = event.data || {};
          if (!playerId || !sheet) return;
          // If this update is for us, update our local sheet and metadata
          if (playerId === currentPlayerId) {
            sheets[playerId] = sheet;
            // Save to metadata so other players (including the GM) can see it
            OBR.player.setMetadata({ journal: sheet });
            if (viewingPlayerId === playerId) {
              renderSheet();
            }
          }
        });
      });
    </script>
  </body>
</html>
